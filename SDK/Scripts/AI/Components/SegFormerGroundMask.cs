#if MV_UNITY_AI_INFERENCE
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using TriInspectorMVCE;
using Unity.InferenceEngine;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

namespace MetaverseCloudEngine.Unity.AI.Components
{
    /// <summary>
    /// Runs SegFormer-B0 (ADE20K) ONNX in Unity Inference and produces a binary "ground" mask.
    /// All model/normalization/class-map details are loaded from a JSON TextAsset (segformer_meta.json).
    /// </summary>
    [HideMonoScript]
    public sealed class SegFormerGroundMask : TriInspectorMonoBehaviour
    {
        [Header("Model & Meta")]
        [Tooltip("ONNX model asset exported by the Python script (segformer_b0_ade20k_512.onnx).")]
        public ModelAsset modelAsset;

        [Tooltip("segformer_meta.json generated by the exporter (TextAsset).")]
        [Required] public TextAsset metaJson;

        [Header("Source")]
        [Tooltip("Source image to segment (camera frame, etc.). If using RawImage, assign sourceRawImage instead.")]
        public Texture sourceTexture;

        [Tooltip("Alternative source via UI RawImage (ignored if Source Texture is set).")]
        public RawImage sourceRawImage;

        [Header("Output")]
        [Tooltip("Final mask output size (pixels). Set to model input size for 1:1, or larger for display.")]
        public int outputWidth  = 512;
        public int outputHeight = 512;

        [Header("Ground Selection (from meta label2id)")]
        [Tooltip("If true, automatically choose ground classes by matching common floor/road/terrain substrings in label names.")]
        public bool autoGroundFromMeta = true;

        [ShowIf(nameof(autoGroundFromMeta), false)]
        [Tooltip("If auto is off, these label NAMES from the meta will be treated as ground (matched via label2id).")]
        public List<string> groundLabelNames = new List<string> { "floor", "road", "sidewalk", "earth", "terrain", "ground", "grass" };

        [Header("Run Loop")]
        [Tooltip("Process every frame (unscaled time).")]
        public bool runInUpdate = true;

        [Range(0, 60)]
        [Tooltip("If > 0, limit to N evaluations per second.")]
        public int updatesPerSecond = 15;

        [Header("Events")]
        public UnityEvent<RenderTexture> onMaskUpdated;

        // ─────────────────────────────────────────────────────────────────────────────
        // Meta model fields (populated from JSON)
        // ─────────────────────────────────────────────────────────────────────────────
        [Serializable]
        private class SegformerMeta
        {
            public int[] input_nchw;                // e.g., [1,3,512,512]
            public int   output_logits_hw_div = 4;  // SegFormer-B0 is /4
            public float[] mean;                    // [0.485, 0.456, 0.406]
            public float[] std;                     // [0.229, 0.224, 0.225]
            public Dictionary<string, string> id2label; // "0": "wall", ...
            public Dictionary<string, int>    label2id; // "wall": 0, ...
        }

        private SegformerMeta _meta;
        private int _inputSize = 512;
        private Vector3 _mean = new(0.485f, 0.456f, 0.406f);
        private Vector3 _std  = new(0.229f, 0.224f, 0.225f);
        private List<int> _groundClassIds = new();

        private Worker _worker;
        private RenderTexture _scratchRT;     // model input (HxW)
        private RenderTexture _maskRT;        // output RT (outputWidth x outputHeight)
        private Texture2D _maskCPU;           // logits spatial (H/4 x W/4 typically)
        private float _nextUpdateTime;

        private static readonly string[] kGroundSubstrings =
        {
            "floor","road","sidewalk","earth","terrain","ground","grass","pavement","path","dirt","sand","snow","track","carpet","tile"
        };

        private void Awake()
        {
            if (!modelAsset)
            {
                Debug.LogError("[SegFormerGroundMask] ModelAsset missing.");
                enabled = false; return;
            }

            if (!LoadMetaFromJson())
            {
                Debug.LogError("[SegFormerGroundMask] Failed to parse meta JSON; component disabled.");
                enabled = false; return;
            }

            // Build worker
            var model = ModelLoader.Load(modelAsset);
            _worker = new Worker(model, Application.platform == RuntimePlatform.WebGLPlayer
                                          ? BackendType.CPU
                                          : BackendType.GPUCompute);

            AllocateIO();
        }

        private bool LoadMetaFromJson()
        {
            if (!metaJson || string.IsNullOrEmpty(metaJson.text)) return false;

            try
            {
                _meta = JsonConvert.DeserializeObject<SegformerMeta>(metaJson.text);
            }
            catch (Exception e)
            {
                Debug.LogError($"[SegFormerGroundMask] JSON parse error: {e}");
                return false;
            }

            if (_meta == null || _meta.input_nchw == null || _meta.input_nchw.Length != 4)
            {
                Debug.LogError("[SegFormerGroundMask] Meta missing 'input_nchw'.");
                return false;
            }

            // Input size from meta
            _inputSize = Mathf.Max(8, _meta.input_nchw[2]); // assume square [1,3,H,W]
            // Mean/Std from meta
            if (_meta.mean != null && _meta.mean.Length >= 3) _mean = new Vector3(_meta.mean[0], _meta.mean[1], _meta.mean[2]);
            if (_meta.std  != null && _meta.std.Length  >= 3) _std  = new Vector3(_meta.std[0],  _meta.std[1],  _meta.std[2]);

            // Choose ground IDs
            _groundClassIds.Clear();
            if (_meta.label2id != null && _meta.label2id.Count > 0)
            {
                if (autoGroundFromMeta)
                {
                    foreach (var kv in _meta.label2id)
                    {
                        var name = kv.Key;
                        if (kGroundSubstrings.Any(s => name.IndexOf(s, StringComparison.OrdinalIgnoreCase) >= 0))
                            _groundClassIds.Add(kv.Value);
                    }
                }
                else
                {
                    foreach (var n in groundLabelNames)
                    {
                        if (_meta.label2id.TryGetValue(n, out var id))
                            _groundClassIds.Add(id);
                        else
                            Debug.LogWarning($"[SegFormerGroundMask] Label '{n}' not found in meta.label2id.");
                    }
                }
            }

            if (_groundClassIds.Count == 0)
                Debug.LogWarning("[SegFormerGroundMask] Ground ID set is empty. No pixels will be marked as ground.");

            // If output size left at default, make it match the model input size for convenience
            if (outputWidth <= 0 || outputHeight <= 0)
            {
                outputWidth = _inputSize;
                outputHeight = _inputSize;
            }

            return true;
        }

        private void AllocateIO()
        {
            // Scratch input RT
            if (_scratchRT) Destroy(_scratchRT);
            _scratchRT = new RenderTexture(_inputSize, _inputSize, 0, RenderTextureFormat.ARGB32)
            {
                filterMode = FilterMode.Bilinear
            };

            // Output mask RT
            if (_maskRT) Destroy(_maskRT);
            _maskRT = new RenderTexture(outputWidth, outputHeight, 0, RenderTextureFormat.R8)
            {
                filterMode = FilterMode.Bilinear
            };

            if (_maskCPU) { Destroy(_maskCPU); _maskCPU = null; }
        }

        private void OnDestroy()
        {
            _worker?.Dispose();
            if (_scratchRT) Destroy(_scratchRT);
            if (_maskRT) Destroy(_maskRT);
            if (_maskCPU) Destroy(_maskCPU);
        }

        private void Update()
        {
            if (!runInUpdate) return;
            var t = Time.unscaledTime;
            if (updatesPerSecond != 0 && t <= _nextUpdateTime) return;
            Evaluate();
            if (updatesPerSecond > 0) _nextUpdateTime = t + 1f / Mathf.Max(1, updatesPerSecond);
        }

        public void Evaluate()
        {
            var src = sourceTexture ? sourceTexture : (sourceRawImage ? sourceRawImage.texture : null);
            if (!src || _worker == null) return;

            // Ensure RT sizes match current settings (in case meta swapped at runtime)
            if (_scratchRT.width != _inputSize || _scratchRT.height != _inputSize) AllocateIO();
            if (_maskRT.width != outputWidth || _maskRT.height != outputHeight)    AllocateIO();

            // Resize to model input
            Graphics.Blit(src, _scratchRT);

            // 1) Write pixels into a device tensor
            using var deviceTensor = new Tensor<float>(new TensorShape(1, 3, _inputSize, _inputSize));
            TextureConverter.ToTensor(_scratchRT, deviceTensor); // device-backed (GPU/compute)

            // 2) Clone to a CPU-readable tensor, then normalize on CPU
            using var input = deviceTensor.ReadbackAndClone(); // <-- key change
            NormalizeCHW(input, _mean, _std);

            // 3) Run the model with the CPU tensor
            _worker.Schedule(input);

            // Fetch logits (expect [1, C, H', W'] with H' = _inputSize / div)
            using var logits = (_worker.PeekOutput("logits") as Tensor<float>)?.ReadbackAndClone();
            if (logits == null) return;

            var C = logits.shape[1];
            var H = logits.shape[2];
            var W = logits.shape[3];

            // Allocate staging CPU texture if needed
            if (_maskCPU == null || _maskCPU.width != W || _maskCPU.height != H)
            {
                if (_maskCPU) Destroy(_maskCPU);
                _maskCPU = new Texture2D(
                    W, H,
                    SystemInfo.SupportsTextureFormat(TextureFormat.R8) ? TextureFormat.R8 : TextureFormat.RGBA32,
                    false
                )
                { filterMode = FilterMode.Point };
            }

            // Argmax → binary ground mask (CPU)
            FillGroundMask(logits, _maskCPU, _groundClassIds);

            // Upload & upscale to RT
            _maskCPU.Apply(false);
            Graphics.Blit(_maskCPU, _maskRT);

            onMaskUpdated?.Invoke(_maskRT);
        }

        private static void NormalizeCHW(Tensor<float> chw01, Vector3 mean, Vector3 std)
        {
            int H = chw01.shape[2], W = chw01.shape[3];
            for (int y = 0; y < H; y++)
            {
                for (int x = 0; x < W; x++)
                {
                    float r = chw01[0, 0, y, x];
                    float g = chw01[0, 1, y, x];
                    float b = chw01[0, 2, y, x];
                    r = (r - mean.x) / std.x;
                    g = (g - mean.y) / std.y;
                    b = (b - mean.z) / std.z;
                    chw01[0, 0, y, x] = r;
                    chw01[0, 1, y, x] = g;
                    chw01[0, 2, y, x] = b;
                }
            }
        }

        private static void FillGroundMask(Tensor<float> logits, Texture2D outTex, List<int> groundIds)
        {
            int C = logits.shape[1], H = logits.shape[2], W = logits.shape[3];
            bool useR8 = outTex.format == TextureFormat.R8;
            var pixels = useR8 ? null : new Color32[W * H];
            var r8 = useR8 ? new byte[W * H] : null;

            // Safety: empty ground set → all zeros
            bool hasGround = groundIds != null && groundIds.Count > 0;

            for (int y = 0; y < H; y++)
            {
                for (int x = 0; x < W; x++)
                {
                    int argmax = 0;
                    float best = float.NegativeInfinity;
                    for (int c = 0; c < C; c++)
                    {
                        float v = logits[0, c, y, x];
                        if (v > best) { best = v; argmax = c; }
                    }

                    byte v8 = (hasGround && groundIds.Contains(argmax)) ? (byte)255 : (byte)0;
                    int idx = y * W + x;

                    if (useR8) r8[idx] = v8;
                    else pixels[idx] = new Color32(v8, v8, v8, 255);
                }
            }

            if (useR8) outTex.LoadRawTextureData(r8);
            else outTex.SetPixels32(pixels);
        }
    }
}
#else
namespace MetaverseCloudEngine.Unity.AI.Components
{
    public class SegFormerGroundMask : InferenceEngineComponent {}
}
#endif
